### 斐波那契数列

问题9.1：用递归和循环实现，输入一个n，求斐波那契数列的第n项
问题9.2：一只青蛙一下可以跳一级或两级台阶，输入n表示有n级台阶，用递归或循环输出共有几种跳法

- 分析：9.2跟9.1其实是一样的：n级台阶的跳法=n-1级台阶跳法+n-2级台阶跳法

相关知识：
重复地计算相同的问题，通常可以选择递归或者循环

树的前序、中序、后序遍历算法代码中，递归实现比循环实现要简单很多，面试官没有要求就尽量用递归

递归的代码比一般循环要简洁很多，一般用递归来解决面试问题，若没有特殊要求的话

递归虽然简洁，但缺点不少：
  1、递归就是函数调用自身的函数，函数调用有时空消耗：
    每次函数调用都需要在内存栈中分配空间以保存参数、返回地址及临时变量，而且往栈里压入弹出data都需要时间
    因此递归实现效率没有循环高
  2、递归中可能很多计算都是重复的，从而对性能带来很大的负面影响：
    递归的本质是把一个问题分解成两个或多个小问题，如果多个小问题存在重叠部分，那么就存在重复计算。
  3、调用栈溢出：
    每次函数调用都需要在内存栈中分配空间，而每个进程的栈的容量是有限的，当递归调用层级太多就会超出栈的容量，导致调用栈溢出，递归代码运行非常容易出错
    
```c++
//===============第一次提交，未通过，测试用例较大，时空消耗不达标
class Solution {
public:
    int Fibonacci(int n) {
        if(n==0)
            return 0;
        if(n==1)
            return 1;
        if(n>1)
            return Fibonacci(n-1) + Fibonacci(n-2); 
    }
};

/*不难发现上面有很多计算都是重复的，重复的计算部分会随n的增大而急剧增大，用递归计算的时间复杂度以n的指数的方式递增
想办法解决计算重复的部分就可以了
时间复杂度O(n)的算法：首先根据f(0),f(1)来计算f(2),在替换一下数值，知道f(n)*/

//===============第二次提交
class Solution {
public:
    int Fibonacci(int n) {
        if(n==0)
            return 0;
        if(n==1)
            return 1;
        int f0 = 0;
        int f1 = 1;
        int fn = 0;   //稍微礼貌性地初始化
        for (int i = 2; i <= n; i++){
            fn = f0 + f1;
            f0 = f1;
            f1 = fn;
        }
     return fn;
    }
};

```









