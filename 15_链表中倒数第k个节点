问题15：输入一个链表和整数k，输出该链表中倒数第k个节点

关于代码鲁棒性：
容错性是鲁棒性的一个重要体现，提高代码鲁棒性的有效措施是进行防御性编程。
防御性编程是指预见在什么地方可能会出现问题，并为这些可能出现的问题制定处理方式。

最简单也是最实用的防御性编程就是入口添加代码以验证用户输入是否符号要求。

//=====第一次提交，栈溢出，反转链表不现实
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
		val(x), next(NULL) {
	}
};*/
class Solution {
public:
    vector<ListNode*> reverseListNode;
    vector<ListNode*> fun(ListNode* pHead){
        ListNode* pNode = pHead;
        if(pNode != NULL)
            if(pNode->next != NULL)
                fun(pNode->next);
        reverseListNode.push_back(pNode);
        return reverseListNode;
    }
    
    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) {
        vector<ListNode*> tmp = fun(pListHead);
        ListNode* res = tmp[k];
        return res;
    }
};

//=====第二次提交，用数值按步计算
class Solution {
public: 
    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) {
        if(pListHead == NULL || k <= 0)     //这里应该把 k <= 0 改成 k == 0判断更加合适
            return NULL;
        ListNode* pNode = pListHead;
        ListNode* resultNode = pListHead;
        while(k--){
            pNode = pNode->next;
        }
        while(pNode){    //这里要到最后的NULL才行，自己画图感受一下
            pNode = pNode->next;
            resultNode = resultNode->next;
        }
        return resultNode;
    }   
};

要考虑的三个要点，忽视的话容易造成程序崩溃：
（1）输入的pListHead为空指针的话，代码会试图访问空指针指向的内存，程序容易崩溃。
（2）输入的以pListHead为头节点的链表的结点总数小于k，遍历链表时容易崩溃。
（3）输入的参数为k为0时，k-1为0xFFFFFFFF（32位）























