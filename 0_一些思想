//=====关于时间效率
（1）要养成采用引用（或指针）传递复杂类型参数的习惯，如果采用值传递的方式，从形参到实参会产生一次复杂复制操作；
（2）若小问题中有相互重叠的部分，那么虽然用递归可以简洁，但时间效率很差；
（3）可以用递归思想来分析，用数组来保存中间结果，并基于循环实现：绝大部分的动态规划算法

//=====关于整数与字符串的转换
C++11 直接to_string（int i）将整形转为string类型字符串

下面的函数转为字符串是char类型
//===最好用：stringstream

    int n = 123456;
    char p[100] = {};
    stringstream s;
    s << n;
    s >> p;

//===其次：springf、sscanf
// 数字转字符串
    sprintf(str, “%d”, num);
// 字符串转数字
    sscanf(str, “%d”, &rsl);
//===再其次：itoa、atoi
    1、数字转字符
    itoa()函数有3个参数：数字、写入转换结果的目标字符串、进制
    itoa(num, string, 10); // 按10进制转换
    2、字符转数字
    char str[4] = {‘1’, ‘2’, ‘3’, ‘4’};
    int num = atoi(str);

//===C++构造函数初始化
C++构造函数初始化顺序只与它们在类中声明的顺序有关，而与初始化列表中的顺序无关；
如
class A
{
private:
    int n1;
    int n2;
public:
    A() : n2(0),n1(n2 + 2) {}
    ....
}
由于n1先于n2被声明，因此n1先初始化，然后再n2初始化；
由于n2还没被初始化，因此它的值是随机的，用 2 + n2 去初始化n1，n1的值也是随机的；
然后n2被0初始化，则n2最终初始值是0





















